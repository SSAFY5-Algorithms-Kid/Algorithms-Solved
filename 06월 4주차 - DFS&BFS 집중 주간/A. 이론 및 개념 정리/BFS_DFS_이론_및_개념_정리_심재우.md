DFS(깊이 우선 탐색) && BFS(너비 우선 탐색)

- DFS와 BFS는 기본적으로 완전 탐색을 목표로 두는 알고리즘이다.
- 모든 정점들을 방문한다는 마음가짐으로 문제를 풀어야 할 경우에 자주 쓰인다.

- DFS와 BFS의 사용 차이

> 모든 정점을 방문하는데에 있어서 제약사항이 없는 경우
> 
>  {{  DFS와 BFS 어느것을 이용해도 괜찮다.  }}

> 정점을 방문하면서 목표 정점까지의 경로에 제약사항이 있는경우
>
> {{ DFS를 사용한다. }} 
> BFS의 경우 이동하는 경로에 대한 제약사항을 거르기가 매우 힘들다..

> 최단거리, 최소시간 등을 구해야 하는 경우
>
> {{  BFS를 사용한다.  }}
> BFS는 가장 가까운 곳부터 내려가면서 경로를 탐색하기 때문에
> 가장 먼저 찾아지는 경우가 가장 최소의 경로가 된다.

- DFS와 BFS의 탐색 순서는 아래와 같다.
> DFS 탐색 순서

![dfs](https://user-images.githubusercontent.com/56018285/123651331-563c7a80-d866-11eb-9132-80d7950cd7ae.png)


> BFS 탐색 순서

![bfs](https://user-images.githubusercontent.com/56018285/123651379-62283c80-d866-11eb-8a44-e5cd9fb7ccc6.png)

- DFS와 BFS의 자료구조 코드 작성 요령

> DFS
>
> DFS의 경우 보편적으로 재귀 함수를 이용한다. 
> 현재 자신의 위치에서 문제의 조건에 따라 한번 더 dfs()로 이동하고
> 문제의 조건에 부합하거나 더 이상 진행이 불가능하다면 
> return 하는 방식으로 재귀를 구현한다.

> BFS
>
> BFS의 경우 보편적으로 Queue 자료구조를 이용한다.
> 방문하는 정점(요소)를 Queue에 넣어가며 
> 더 이상 Queue에 요소가 남아있지 않을 때까지 
> while 반복을 하는 방식으로 구현한다.

- 주의할 점

> 거의 필수적으로 방문 여부를 체크 해주어야 한다.
> boolean 이나 int 배열 등을 이용해서
> 방문을 했다면 true, 1 등으로 체크해주는 방식을 이용한다.

> 방문여부를 체크해주지 않는다면 재귀, while 문이 무한으로 반복하여 돌거나
> 방문을 했던 정점을 다시 방문을 하는 경우가 생겨서
> 시간적으로 큰 손해가 발생한다.

> 추가적으로 BFS에서 방문 배열을 int형으로 선언해주어 사용할 때
> 다음 정점의 방문 배열의 값을 이전 정점의 방문 배열의 값 +1 을 해주면
> 간단하게 깊이를 체크할 수 있다.

> 예시 코드)
> 
> boolean[] v = new boolean[N];
>
> queue.offer(start);
>
> v[0]=0;
>
> // start 일때 깊이는 0
> 
> while(!queue.isEmpty()){
> 
>   int curr = queue.poll();
>   
>   // 조건(로직)
>   
>     queue.offer(next);
>     
>     v[next] = v[curr]+1;
>     
>     // next 의 깊이는 이전 노드의 깊이 +1 이된다.
>     
> }

>위와 같은 방법을 이용해 방문여부를 체크함과 
>동시에 깊이 또한 알아낼 수 있다.
